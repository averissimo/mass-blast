#
#
# separate each transcriptome in a individual folder
#  this will create many folders in the output directory
#  each ending with the database name
separate_db: true
#
#
# number of threads to use
#  only valid with separate_db option
use_threads: 2
#
#
# Threshold that should filter out results by identity
#  values can take between 0 and 1 (i.e. 0% and 100%)
identity:
  # minimum range for identity
  min: .40
  # maximum range for identity
  max: 1
#
#
# Filtering options
#
prune_identical:
  #  use_worst: will pick the result with highest identity if false
  #   and the lowest identity if true
  use_worst: false
  # first: the initial filtering step will remove all identical sseqid and
  #  pick the best/worst (depending on use_worst option)
  first: sseqid
  # list: list of subsequent filtering columns, works the same as first
  list:
    - nt_aligned_seq
#
#
# output directory options:
#  - ext: extension for blast files
#  - dir: corresponds to the directory's name and path where will be stored the results. By default, it is set to “output".
#  - extension: extension for blast files, by default “.out”.
#  - intermediate: corresponds to the directory’s name where will be saved all the intermediate files generated by MassBlast.
#  - blast_results: corresponds to the directory’s name where will be saved all the Blast results generated by Blast+.
#  - fastas: corresponds to the directory’s name where will be saved all the fasta files generated by MassBlast.
#
output:
  dir: output
  extension: .out
  intermediate: intermediate
  blast_results: blast_results
  fastas: fasta_files
#
# Configuration for finding longest ORF
#  that requires:
#  - start codon: sequence that indicates where ORF begins
#  - stop codon: sequence that indicates where ORF ends
#  - reverse: search the reverse sequence
#  - direct: search the given sequence (at least this and reverse must be used)
#  - min: minimum size of sequence
#  - max: maximum size of sequence
orf:
  stop_codon:
    - tag
    - taa
    - tga
  start_codon:
    - atg
  reverse: true
  direct: true
  min: 120
#
codon_table: 1
#
debug:
  level: "info"
  file: output/log.txt
  show_stdout_if_file: true

config:
  user: user.yml
#
# removes blanks lines
clean_output: true

#
force_remove: true
#
# value for filtering the results on the identity
#  column, i.e. only above 40% in case the config is .40
identity:
  min: .40 # value between 0 and 1
  max: 1   # value between 0 and 1

#
# Directory that holds all database files in blastdb format
#  if you need to convert a fasta file to this format, you
#  can use the tool from blast+:
#    $ makeblastdb
#  or put the files in db_and_queries/import_db and run the
#  the script that is in that folder
db:
  parent: db_and_queries/db
  # In case list is empty it will use all blast dbs in parent
  #  that have a .nhr extension
  list:
#
# Directories that holds all queries in form of fasta files
# All query files must have as extensions:
#  .fasta .query .fas .fna
query:
  parent: db_and_queries
  # It supports multiple folders holding the queries by
  #  adding new lines in 'folders' options
  # note: all new lines must follow indentation and start
  #  with a dash '-' (without quotes)
  folders:
    - queries
#
#
# directory where csv are kept to add annotation to the results
#  each csv should have at least 3 columns, with headers
# the csv must be separated by tabs (\t)
#
# column 1 & 2: header should match columns in the trimmed.csv results and
#  each line that matches will be added the following columns
#
# columns 3 and on: header will be the header of the new column and information
#  on these columns will be added to the matched elements
#
# example:
# db          sseqid    expression_level
# backberry   comp20_u1 23
# backberry   comp33_u1 33
# bilberry    comp33_u1 42
# ....
annotation_dir: db_and_queries/annotation
#
# how to format the output file. by default should show all columns
format:
  outfmt: 6

  specifiers:
    qseqid: "means Query Seq-id"
    evalue: "means Expect value"
    pident: "means Percentage of identical matches"
    qcovs: "means Query Coverage Per Subject"
    qgi: "means Query GI"
    qacc: "means Query accesion"
    sseqid: "means Subject Seq-id"
    sallseqid: "means All subject Seq-id(s), separated by a ';'"
    sgi: "means Subject GI"
    sallgi: "means All subject GIs"
    sacc: "means Subject accession"
    sallacc: "means All subject accessions"
    qstart: "means Start of alignment in query"
    qend: "means End of alignment in query"
    sstart: "means Start of alignment in subject"
    send: "means End of alignment in subject"
    bitscore: "means Bit score"
    score: "means Raw score"
    length: "means Alignment length"
    nident: "means Number of identical matches"
    mismatch: "means Number of mismatches"
    positive: "means Number of positive-scoring matches"
    gapopen: "means Number of gap openings"
    gaps: "means Total number of gap"
    ppos: "means Percentage of positive-scoring matches"
    frames: "means Query and subject frames separated by a '/'"
    qframe: "means Query frame"
    sframe: "means Subject frame"
    btop: "means Blast traceback operations (BTOP)"
    staxids: "means unique Subject Taxonomy ID(s), separated by a ';'(in numerical order)"
    sscinames: "means unique Subject Scientific Name(s), separated by a ';'"
    scomnames: "means unique Subject Common Name(s), separated by a ';'"
    sblastnames: "means unique Subject Blast Name(s), separated by a ';' (in alphabetical order)"
    sskingdoms: "means unique Subject Super Kingdom(s), separated by a ';' (in alphabetical order)"
    stitle: "means Subject Title"
    salltitles: "means All Subject Title(s), separated by a '<>'"
    sstrand: "means Subject Strand"
    qcovhsp: "means Query Coverage Per HSP"
    qseq: "means Aligned part of query sequence"
    sseq: "means Aligned part of subject sequence"
